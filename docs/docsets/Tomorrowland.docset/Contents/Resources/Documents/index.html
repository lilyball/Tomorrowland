<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Tomorrowland  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Tomorrowland  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Tomorrowland Docs</a> (100% documented)</p>
        <p class="header-right"><a href="https://github.com/kballard/Tomorrowland"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Tomorrowland Reference</a>
        <img id="carat" src="img/carat.png" />
        Tomorrowland  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/NoError.html">NoError</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PromiseCallbackError.html">PromiseCallbackError</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PromiseContext.html">PromiseContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PromiseResult.html">PromiseResult</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PromiseTimeoutError.html">PromiseTimeoutError</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Functions.html">Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4whenAA7PromiseVyxq_GSayAEG5first_Sb15cancelRemainingtr0_lF">when(first:cancelRemaining:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4whenAA7PromiseVyx_q_q0_q1_q2_q3_tq4_GADyxq4_G9fulfilled_ADyq_q4_GADyq0_q4_GADyq1_q4_GADyq2_q4_GADyq3_q4_G8Dispatch0E3QoSV0F6SClassO3qosSb15cancelOnFailuretr5_lF">when(fulfilled:_:_:_:_:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4whenAA7PromiseVyx_q_q0_q1_q2_tq3_GADyxq3_G9fulfilled_ADyq_q3_GADyq0_q3_GADyq1_q3_GADyq2_q3_G8Dispatch0E3QoSV0F6SClassO3qosSb15cancelOnFailuretr4_lF">when(fulfilled:_:_:_:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4whenAA7PromiseVyx_q_q0_q1_tq2_GADyxq2_G9fulfilled_ADyq_q2_GADyq0_q2_GADyq1_q2_G8Dispatch0E3QoSV0F6SClassO3qosSb15cancelOnFailuretr3_lF">when(fulfilled:_:_:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4whenAA7PromiseVyx_q_q0_tq1_GADyxq1_G9fulfilled_ADyq_q1_GADyq0_q1_G8Dispatch0E3QoSV0F6SClassO3qosSb15cancelOnFailuretr2_lF">when(fulfilled:_:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4whenAA7PromiseVyx_q_tq0_GADyxq0_G9fulfilled_ADyq_q0_G8Dispatch0E3QoSV0F6SClassO3qosSb15cancelOnFailuretr1_lF">when(fulfilled:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4whenAA7PromiseVySayxGq_GSayADyxq_GG9fulfilled_8Dispatch0E3QoSV0F6SClassO3qosSb15cancelOnFailuretr0_lF">when(fulfilled:qos:cancelOnFailure:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/DelayedPromise.html">DelayedPromise</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Promise.html">Promise</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Promise/Resolver.html">– Resolver</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs.html#/s:12Tomorrowland18PromiseCancellableV">PromiseCancellable</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/TokenPromise.html">TokenPromise</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:12Tomorrowland17StdDelayedPromisea">StdDelayedPromise</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:12Tomorrowland10StdPromisea">StdPromise</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h1 id='tomorrowland' class='heading'>Tomorrowland</h1>

<p><a href="https://github.com/kballard/Tomorrowland/releases/latest"><img src="https://img.shields.io/badge/version-v0.3.2-blue.svg" alt="Version"></a>
<img src="https://img.shields.io/badge/platforms-ios%20%7C%20macos%20%7C%20watchos%20%7C%20tvos-lightgrey.svg" alt="Platforms">
<img src="https://img.shields.io/badge/languages-swift%20%7C%20objc-orange.svg" alt="Languages">
<img src="https://img.shields.io/badge/license-MIT%2FApache-blue.svg" alt="License">
<img src="https://img.shields.io/cocoapods/v/Tomorrowland.svg" alt="CocoaPods">
<a href="https://github.com/carthage/carthage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible"></a></p>

<p>Tomorrowland is an implementation of <a href="https://en.wikipedia.org/wiki/Futures_and_promises">Promises</a> for Swift and Objective-C. A Promise is a wrapper around an
asynchronous task that provides a standard way of subscribing to task resolution as well as chaining promises together.</p>
<pre class="highlight swift"><code><span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">true</span>
<span class="kt">MyAPI</span><span class="o">.</span><span class="nf">requestFeed</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">user</span><span class="p">)</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="p">(</span><span class="n">feedItems</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">refreshUI</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">feedItems</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">showError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">always</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>

<p>It is loosely based on both <a href="http://promisekit.org/">PromiseKit</a> and <a href="https://github.com/malcommac/Hydra">Hydra</a>, with a few key distinctions:</p>

<ul>
<li>It uses atomics internally instead of creating a separate <code>DispatchQueue</code> for each promise. This means it&rsquo;s faster and uses fewer resources.</li>
<li>It provides full support for cancellable promises. PromiseKit supports detection of <q>cancelled</q> errors but has no way to request cancellation of a promise. Hydra
supports cancelling a promise, but it can&rsquo;t actually stop any work being done by the promise unless the promise body itself polls for the cancellation status (so e.g.
a promise wrapping a network task can&rsquo;t reasonably cancel the network task). Tomorrowland improves on this by allowing the promise body to observe the
cancelled state, and allows linking cancellation of a child promise to its parent.</li>
<li>Its Obj-C support makes use of generics for improved type safety and better documentation.</li>
<li>Like Hydra but unlike PromiseKit, it provides a way to suppress a registered callback (e.g. because you don&rsquo;t care about the result anymore and don&rsquo;t want stale
data affecting your UI). This is distinct from promise cancellation.</li>
<li>Tomorrowland promises are fully generic over the error type, whereas both PromiseKit and Hydra only support using <code>Error</code> as the error type. This may result in
more typing to construct a promise but it allows for much more powerful error handling. Tomorrowland also has some affordances for working with promises that
use <code>Error</code> as the error type.</li>
<li>Tomorrowland is fully thread-safe. I have no reason to believe PromiseKit isn&rsquo;t, but (at the time of this writing) there are parts of Hydra that are incorrectly
implemented in a non-thread-safe manner.</li>
</ul>
<h2 id='installation' class='heading'>Installation</h2>
<h3 id='manually' class='heading'>Manually</h3>

<p>You can add Tomorrowland to your workspace manually like any other project and add the resulting <code>Tomorrowland.framework</code> to your application&rsquo;s frameworks.</p>
<h3 id='carthage' class='heading'>Carthage</h3>
<pre class="highlight plaintext"><code>github "kballard/Tomorrowland" ~&gt; 0.3.0
</code></pre>
<h3 id='cocoapods' class='heading'>CocoaPods</h3>
<pre class="highlight ruby"><code><span class="n">pod</span> <span class="s1">'Tomorrowland'</span><span class="p">,</span> <span class="s1">'~&gt; 0.3.0'</span>
</code></pre>
<h3 id='swiftpm' class='heading'>SwiftPM</h3>

<p>Tomorrowland currently relies on a private Obj-C module for its atomics. This arrangement means it is not compatible with Swift Package Manager (as adding
compatibility would necessitate publicly exposing the private Obj-C module).</p>
<h2 id='quick-start' class='heading'>Quick Start</h2>
<h3 id='creating-promises' class='heading'>Creating Promises</h3>

<p>Promises can be created using code like the following:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span><span class="kt">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">resolver</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">try</span> <span class="nf">expensiveCalculation</span><span class="p">()</span>
    <span class="n">resolver</span><span class="o">.</span><span class="nf">fulfill</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
<span class="p">})</span>
</code></pre>

<p>The body of this promise runs on the specified <code><a href="Enums/PromiseContext.html">PromiseContext</a></code>, which in this case is <code>.utility</code> (which means <code>DispatchQueue.global(qos: .utility)</code>).
Unlike callbacks, all created promises must specify a context, so as to avoid accidentally running expensive computations on the main thread. The available contexts
include <code>.main</code>, every Dispatch QoS, a specific <code>DispatchQueue</code>, a specific <code>OperationQueue</code>, or the value <code>.immediate</code> which means to run the block
synchronously. There&rsquo;s also the special context <code>.auto</code>, which evaluates to <code>.main</code> on the main thread and <code>.default</code> otherwise. This special context is the default
context for all callbacks that don&rsquo;t otherwise specify one.</p>

<p><strong>Note:</strong> The <code>.immediate</code> context can be dangerous to use for callback handlers and should be avoided in most cases. It&rsquo;s primarily intended for creating
promises, and whenever it&rsquo;s used with a callback handler the handler must be prepared to execute on <em>any thread</em>. For callbacks it&rsquo;s usually only useful for short
thread-agnostic callbacks, such as an <code>.onRequestCancel</code> that does nothing more than cancelling a <code>URLSessionTask</code>.</p>

<p>The body of a <code><a href="Structs/Promise.html">Promise</a></code> receives a <q>resolver</q>, which it must use to fulfill, reject, or cancel the promise. If the resolver goes out of scope without being used, the
promise is automatically cancelled. If the promise&rsquo;s error type is <code>Error</code>, the promise body may also throw an error (as seen above), which is then used to reject the
promise. This resolver can also be used to observe cancellation requests using <code>resolver.onRequestCancel</code>, as seen here:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">Data</span><span class="p">,</span><span class="kt">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">immediate</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">resolver</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="n">urlSession</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">completionHandler</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="n">data</span> <span class="p">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="nf">fulfill</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">case</span> <span class="kt">URLError</span><span class="o">.</span><span class="n">cancelled</span><span class="p">?</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="nf">reject</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="n">resolver</span><span class="o">.</span><span class="nf">onRequestCancel</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">immediate</span><span class="p">,</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
        <span class="n">task</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="n">task</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
<span class="p">})</span>
</code></pre>

<p>Resolvers also have a convenience method <code>handleCallback()</code> that is intended to make it easy to wrap framework callbacks in promises. This method returns a
closure that can be used as a callback directly. It also takes an optional <code>isCancelError</code> parameter that can be used to indicate when an error represents
cancellation. For example:</p>
<pre class="highlight swift"><code><span class="n">geocoder</span><span class="o">.</span><span class="nf">reverseGeocodeLocation</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nv">completionHandler</span><span class="p">:</span> <span class="n">resolver</span><span class="o">.</span><span class="nf">handleCallback</span><span class="p">(</span><span class="nv">isCancelError</span><span class="p">:</span> <span class="p">{</span> <span class="kt">CLError</span><span class="o">.</span><span class="n">geocodeCanceled</span> <span class="o">~=</span> <span class="nv">$0</span> <span class="p">}))</span>
</code></pre>
<h3 id='using-promises' class='heading'>Using Promises</h3>

<p>Once you have a promise, you can register callbacks to be executed when the promise is resolved. As mentioned above, you can specify the context for the
callback, but if you don&rsquo;t specify it then it defaults to <code>.auto</code>, which means the main thread if the callback is registered from the main thread, otherwise the dispatch
queue with QoS <code>.default</code>.</p>

<p>When you register a callback, the method also returns a <code><a href="Structs/Promise.html">Promise</a></code>. All callback registration methods return a new <code><a href="Structs/Promise.html">Promise</a></code> even if the callback doesn&rsquo;t affect the
value of the promise. The reason for this is so chained callbacks always guarantee that the previous callback finished executing before the new one starts, even
when using concurrent contexts (e.g. <code>.utility</code>).</p>

<p>Most callback registration methods also have versions that allow you to return a <code><a href="Structs/Promise.html">Promise</a></code> from your callback. In this event, the resulting <code><a href="Structs/Promise.html">Promise</a></code> waits for the
promise you returned to resolve before adopting its value. This allows for easy composition of promises.</p>
<pre class="highlight swift"><code><span class="nf">showLoadingIndicator</span><span class="p">()</span>
<span class="nf">fetchUserCredentials</span><span class="p">()</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="p">(</span><span class="n">credentials</span><span class="p">)</span> <span class="k">in</span>
    <span class="c1">// This returns a new promise</span>
    <span class="k">return</span> <span class="kt">MyAPI</span><span class="o">.</span><span class="nf">login</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">credentials</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nv">password</span><span class="p">:</span> <span class="n">credentials</span><span class="o">.</span><span class="n">password</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">apiKey</span><span class="p">)</span> <span class="k">in</span>
    <span class="c1">// this is invoked when the promise returned by MyAPI.login fulfills.</span>
    <span class="kt">MyAPI</span><span class="o">.</span><span class="n">apiKey</span> <span class="o">=</span> <span class="n">apiKey</span>
    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">transitionToLoggedInState</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">always</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
    <span class="c1">// This is always invoked regardless of whether the previous chain was</span>
    <span class="c1">// fulfilled, rejected, or cancelled.</span>
    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">hideLoadingIndicator</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
    <span class="c1">// this handles any error returned from the previous chain, meaning any error</span>
    <span class="c1">// from `fetchUserCredentials()` or from `MyAPI.login(name:password:)`.</span>
    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">displayError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>When composing callbacks that return promises, you may run into issues with incompatible error types. There are convenience methods for working with promises
whose errors are compatible with <code>Error</code>, but they don&rsquo;t cover all cases. If you find yourself hitting one of these cases, any <code><a href="Structs/Promise.html">Promise</a></code> whose error type conforms to
<code>Error</code> has a property <code>.upcast</code> that will convert that error into an <code>Error</code> to allow for easier composition of promises.</p>

<p>Tomorrowland also offers a typealias <code><a href="Typealiases.html#/s:12Tomorrowland10StdPromisea">StdPromise&lt;Value&gt;</a></code> as shorthand for <code><a href="Structs/Promise.html">Promise&lt;T,Error&gt;</a></code>. This is frequently useful to avoid having to repeat the types,
such as with <code>StdPromise(fulfilled: someValue)</code> instead of <code>Promise&lt;SomeValue,Error&gt;(fulfilled: someValue)</code>.</p>
<h3 id='cancelling-and-invalidation' class='heading'>Cancelling and Invalidation</h3>

<p>All promises expose a method <code>.requestCancel()</code>. It is named such because this doesn&rsquo;t actually guarantee that the promise will be cancelled. If the promise
supports cancellation, this method will trigger a callback that the promise can use to cancel its work. But promises that don&rsquo;t support cancellation will ignore this
and will eventually fulfill or reject as normal. Naturally, requesting cancellation of a promise that has already been resolved does nothing, even if the callbacks have
not yet been invoked.</p>

<p>In order to handle the issue of a promise being resolved after you no longer care about it, there is a separate mechanism called a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>
that can be used to suppress callbacks. All callback methods have an optional <code>token</code> parameter that accepts a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>.  If provided,
calling <code>invalidate()</code> on the token prior to the callback being executed guarantees the callback will not fire. If the callback returns a value that is required in order
to resolve the <code><a href="Structs/Promise.html">Promise</a></code> returned from the callback registration method, the resulting <code><a href="Structs/Promise.html">Promise</a></code> is cancelled instead. <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s can be used
with multiple callbacks at once, and a single token can be re-used as much as desired. It is recommended that you take advantage of both invalidation tokens and
cancellation. This may look like</p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">URLImageView</span><span class="p">:</span> <span class="kt">UIImageView</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">promise</span><span class="p">:</span> <span class="kt">StdPromise</span><span class="o">&lt;</span><span class="kt">Void</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">invalidationToken</span> <span class="o">=</span> <span class="kt">PromiseInvalidationToken</span><span class="p">()</span>

    <span class="kd">enum</span> <span class="kt">LoadError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">dataIsNotImage</span>
    <span class="p">}</span>

    <span class="c1">/// Loads an image from the URL and displays it in the image view.</span>
    <span class="kd">func</span> <span class="nf">loadImage</span><span class="p">(</span><span class="n">from</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">promise</span><span class="p">?</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
        <span class="n">invalidationToken</span><span class="o">.</span><span class="nf">invalidate</span><span class="p">()</span>
        <span class="c1">// Note: dataTaskAsPromise does not actually exist</span>
        <span class="n">promise</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskAsPromise</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
        <span class="c1">// Use `_ =` to avoid having to handle errors with `.catch`.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">promise</span><span class="p">?</span><span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">image</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">LoadError</span><span class="o">.</span><span class="n">dataIsNotImage</span>
            <span class="p">}</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">token</span><span class="p">:</span> <span class="n">invalidationToken</span><span class="p">,</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p><code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code> also has a method <code>.requestCancelOnInvalidate(_:)</code> that can register any number of <code><a href="Structs/Promise.html">Promise</a></code>s to be automatically
requested to cancel (using <code>.requestCancel()</code>) the next time the token is invalidated. <code><a href="Structs/Promise.html">Promise</a></code> also has the same method (except it takes a token as the
argument) as a convenience for calling <code>.requestCancelOnInvalidate(_:)</code> on the token. This can be used to terminate a promise chain without ever assigning
the promise to a local variable.</p>

<p>By default <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s will invalidate themselves automatically when deinitialized. This is primarily useful in conjunction with
<code>requestCancelOnInvalidate(_:)</code> as it allows you to automatically cancel your promises when object that owns the token deinits. This behavior can be
disabled with an optional parameter to <code>init</code>.</p>

<p><code><a href="Structs/Promise.html">Promise</a></code> also has a convenience method <code>requestCancelOnDeinit(_:)</code> which can be used to request the <code><a href="Structs/Promise.html">Promise</a></code> to be cancelled when a given object
deinits. This is equivalent to adding a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code> property to the object (configured to invalidate on deinit) and requesting cancellation when
the token invalidates, but can be used if the token would otherwise not be explicitly invalidated.</p>

<p>Using these methods, the above <code>loadImage(from:)</code> can be rewritten as the following including cancellation:</p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">URLImageView</span><span class="p">:</span> <span class="kt">UIImageView</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">promiseToken</span> <span class="o">=</span> <span class="kt">PromiseInvalidationToken</span><span class="p">()</span>

    <span class="kd">enum</span> <span class="kt">LoadError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">dataIsNotImage</span>
    <span class="p">}</span>

    <span class="c1">/// Loads an image from the URL and displays it in the image view.</span>
    <span class="kd">func</span> <span class="nf">loadImage</span><span class="p">(</span><span class="n">from</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">promiseToken</span><span class="o">.</span><span class="nf">invalidate</span><span class="p">()</span>
        <span class="c1">// Note: dataTaskAsPromise does not actually exist</span>
        <span class="n">promise</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskAsPromise</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
        <span class="c1">// Use `_ =` to avoid having to handle errors with `.catch`.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">promise</span><span class="p">?</span><span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">image</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">LoadError</span><span class="o">.</span><span class="n">dataIsNotImage</span>
            <span class="p">}</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">token</span><span class="p">:</span> <span class="n">promiseToken</span><span class="p">,</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">requestCancelOnInvalidate</span><span class="p">(</span><span class="n">invalidationToken</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h4 id='code-tokenpromise-code' class='heading'><code><a href="Structs/TokenPromise.html">TokenPromise</a></code></h4>

<p>In order to avoid the repetition of passing a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code> to multiple <code><a href="Structs/Promise.html">Promise</a></code> methods as well as cancelling the resulting promise, a type
<code><a href="Structs/TokenPromise.html">TokenPromise</a></code> exists that handles this for you. You can create a <code><a href="Structs/TokenPromise.html">TokenPromise</a></code> with the <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV9withTokenAA0dB0Vyxq_GAA0b12InvalidationD0VF">Promise.withToken(_:)</a></code> method. This allows you to take code like
the following:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">loadModel</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">promiseToken</span><span class="o">.</span><span class="nf">invalidate</span><span class="p">()</span>
    <span class="kt">MyModel</span><span class="o">.</span><span class="nf">fetchFromNetworkAsPromise</span><span class="p">()</span>
        <span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">token</span><span class="p">:</span> <span class="n">promiseToken</span><span class="p">,</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">updateUI</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">catch</span><span class="p">(</span><span class="nv">token</span><span class="p">:</span> <span class="n">promiseToken</span><span class="p">,</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">handleError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">requestCancelOnInvalidate</span><span class="p">(</span><span class="n">promiseToken</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>And rewrite it to be less repetitive:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">loadModel</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">promiseToken</span><span class="o">.</span><span class="nf">invalidate</span><span class="p">()</span>
    <span class="kt">MyModel</span><span class="o">.</span><span class="nf">fetchFromNetworkAsPromise</span><span class="p">()</span>
        <span class="o">.</span><span class="nf">withToken</span><span class="p">(</span><span class="n">promiseToken</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">then</span><span class="p">({</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">updateUI</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">catch</span><span class="p">({</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">handleError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<h4 id='automatic-cancellation-propagation' class='heading'>Automatic cancellation propagation</h4>

<p>Nearly all callback registration methods will automatically propagate cancellation requests from the child to the parent if the parent has no other observers. If all
observers for a promise request cancellation, the cancellation request will propagate upwards at this time. This means that a promise will not automatically cancel
as long as there&rsquo;s at least one interested observer. Do note that promises that have no observers do not get automatically cancelled, this only happens if there&rsquo;s at
least one observer (which then requests cancellation). Automatic cancellation propagation also requires that the promise itself no longer be in scope. For this reason
you should avoid holding onto promises long-term and instead use the <code>.cancellable</code> property or <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>&lsquo;s
<code>requestCancelOnInvalidate(_:)</code> if you want to be able to cancel the promise later.</p>

<p>Automatic cancellation propagation also works with the utility functions <code>when(fulfilled:)</code> and <code>when(first:)</code> as well as the convenience methods
<code>timeout(on:delay:)</code> and <code>delay(on:_:)</code>.</p>

<p>Promises have a couple of methods that do not participate in automatic cancellation propagation. You can use <code>tap(on:token:_:)</code> as an alternative to <code>always</code> in
order to register an observer that won&rsquo;t interfere with the existing automatic cancellation propagation (this is suitable for inserting into the middle of a promise
chain). You can also use <code>tap()</code> as a more generic version of this.</p>

<p>Note that <code>ignoringCancel()</code> disables automatic cancellation propagation on the receiver. Once you invoke this on a promise, it will never automatically cancel.</p>
<h3 id='promise-helpers' class='heading'>Promise Helpers</h3>

<p>There are a few helper functions that can be used to deal with multiple promises.</p>
<h4 id='code-when-fulfilled-code' class='heading'><code>when(fulfilled:)</code></h4>

<p><code>when(fulfilled:)</code> is a global function that takes either an array of promises or 2–6 promises as separate arguments, and returns a single promise that is
eventually fulfilled with the values of all input promises. With the array version all input promises must have the same type and the result is fulfilled with an array.
With the separate argument version the promises may have unique value types (but the same error type) and the result is fulfilled with a tuple.</p>

<p>If any of the input promises is rejected or cancelled, the resulting promise is immediately rejected or cancelled as well. If multiple input promises are rejected or
cancelled, the first such one affects the result.</p>

<p>This function has an optional parameter <code>cancelOnFailure:</code> that, if provided as <code>true</code>, will cancel all input promises if any of them are rejected.</p>
<h4 id='code-when-first-code' class='heading'><code>when(first:)</code></h4>

<p><code>when(first:)</code> is a global function that takes an array of promises of the same type, and returns a single promise that eventually adopts the same value or error as
the first input promise that gets fulfilled or rejected. Cancelled input promises are ignored, unless all input promsies are cancelled, at which point the resulting
promise will be cancelled as well.</p>

<p>This function has an optional parameter <code>cancelRemaining:</code> that, if provided as <code>true</code>, will cancel the remaining input promises as soon as one of them is fulfilled
or rejected.</p>
<h4 id='code-promise-timeout-on-delay-code' class='heading'><code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV7timeoutACyxAA0B12TimeoutErrorOyq_GGAA0B7ContextO2on_Sd5delaytF">Promise.timeout(on:delay:)</a></code></h4>

<p><code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV7timeoutACyxAA0B12TimeoutErrorOyq_GGAA0B7ContextO2on_Sd5delaytF">Promise.timeout(on:delay:)</a></code> is a method that returns a new promise that adopts the same value as the receiver, or is rejected with an error if the receiver isn&rsquo;t
resolved within the given interval.</p>
<h4 id='code-promise-delay-on-_-code' class='heading'><code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV5delayACyxq_GAA0B7ContextO2on_SdtF">Promise.delay(on:_:)</a></code></h4>

<p><code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV5delayACyxq_GAA0B7ContextO2on_SdtF">Promise.delay(on:_:)</a></code> is a method that returns a new promise that adopts the same result as the receiver after the specified delay. It is intended primarily for
testing purposes.</p>
<h3 id='objective-c' class='heading'>Objective-C</h3>

<p>Tomorrowland has Obj-C compatibility in the form of <code>TWLPromise&lt;ValueType,ErrorType&gt;</code>. This is a parallel promise implementation that can be bridged to/from
<code><a href="Structs/Promise.html">Promise</a></code> and supports all of the same functionality. Note that some of the method names are different (due to lack of overloading), and while <code>TWLPromise</code> is
generic over its types, the return values of callback registration methods that return new promises are not parameterized (due to inability to have generic methods).</p>
<h2 id='requirements' class='heading'>Requirements</h2>

<p>Requires a minimum of iOS 9, macOS 10.10, watchOS 2.0, or tvOS 9.0.</p>
<h2 id='license' class='heading'>License</h2>

<p>Licensed under either of</p>

<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or
<a href="http://opensource.org/licenses/MIT">http://opensource.org/licenses/MIT</a>) at your option.</li>
</ul>
<h3 id='contribution' class='heading'>Contribution</h3>

<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be dual licensed as above, without any additional terms or conditions.</p>
<h2 id='version-history' class='heading'>Version History</h2>
<h3 id='v0-3-2' class='heading'>v0.3.2</h3>

<ul>
<li>Add <code>Hashable</code> / <code>Equatable</code> conformance to <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>.</li>
<li>Add a new type <code><a href="Structs/TokenPromise.html">TokenPromise</a></code> that wraps a <code><a href="Structs/Promise.html">Promise</a></code> and automatically applies a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>. This API is Swift-only.</li>
</ul>
<h3 id='v0-3-1' class='heading'>v0.3.1</h3>

<ul>
<li>Add a missing Swift-&gt;ObjC convenience bridging method.</li>
<li>Add <code>Decodable</code> conformance to <code><a href="Enums/NoError.html">NoError</a></code>.</li>
<li>Add method <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV4forkACyxq_GyAEKcKF">Promise.fork(_:)</a></code>.</li>
<li>Fix compilation failure when targeting 32-bit iOS 9 simulator in Xcode 9.3.</li>
<li>Fix cancellation propagation test cases on iOS 9 simulators.</li>
</ul>
<h3 id='v0-3' class='heading'>v0.3</h3>

<ul>
<li>Add <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV25requestCancelOnInvalidateACyxq_GAA0B17InvalidationTokenVF">Promise.requestCancelOnInvalidate(_:)</a></code> as a convenience for <code>token.requestCancelOnInvalidate(_:)</code>.</li>
<li>Add <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV21requestCancelOnDeinitACyxq_GyXlF">Promise.requestCancelOnDeinit(_:)</a></code> as a convenience for adding a token property to an object that invalites on deinit.</li>
<li>Better support for <code>OperationQueue</code> with <code>delay</code>/<code>timeout</code>. Instead of using the <code>OperationQueue</code>&rsquo;s underlying queue, we instead use a <code>.userInitiated</code>
queue for the timer and hop onto the <code>OperationQueue</code> to resolve the promise.</li>
</ul>
<h3 id='v0-2' class='heading'>v0.2</h3>

<ul>
<li>Implement automatic cancellation propagation and remove the <code>.linkCancel</code> option.</li>
<li>Remove the <code>cancelOnTimeout:</code> parameter to <code>timeout(on:delay:)</code> in favor of automatic cancellation propagation.</li>
<li>Automatically invalidate <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s on <code>deinit</code>. This behavior can be disabled via a parameter to <code>init</code>.</li>
</ul>
<h3 id='v0-1' class='heading'>v0.1</h3>

<p>Initial alpha release.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2018 <a class="link" href="https://github.com/kballard/Tomorrowland" target="_blank" rel="external">Kevin Ballard</a>. All rights reserved. (Last updated: 2018-05-20)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.9.3</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
