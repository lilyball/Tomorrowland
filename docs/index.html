<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Tomorrowland  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Tomorrowland  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Tomorrowland Docs</a> (100% documented)</p>
        <p class="header-right"><a href="https://github.com/lilyball/Tomorrowland"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Tomorrowland Reference</a>
        <img id="carat" src="img/carat.png" />
        Tomorrowland  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/NoError.html">NoError</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PromiseCallbackError.html">PromiseCallbackError</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PromiseContext.html">PromiseContext</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PromiseResult.html">PromiseResult</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/PromiseTimeoutError.html">PromiseTimeoutError</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Functions.html">Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4when5first15cancelRemainingAA7PromiseVyxq_GSayAGG_Sbtr0_lF">when(first:cancelRemaining:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4when9fulfilled_____3qos15cancelOnFailureAA7PromiseVyx_q_q0_q1_q2_q3_tq4_GAGyxq4_G_AGyq_q4_GAGyq0_q4_GAGyq1_q4_GAGyq2_q4_GAGyq3_q4_G8Dispatch0I3QoSV0J6SClassOSbtr5_lF">when(fulfilled:_:_:_:_:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4when9fulfilled____3qos15cancelOnFailureAA7PromiseVyx_q_q0_q1_q2_tq3_GAGyxq3_G_AGyq_q3_GAGyq0_q3_GAGyq1_q3_GAGyq2_q3_G8Dispatch0I3QoSV0J6SClassOSbtr4_lF">when(fulfilled:_:_:_:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4when9fulfilled___3qos15cancelOnFailureAA7PromiseVyx_q_q0_q1_tq2_GAGyxq2_G_AGyq_q2_GAGyq0_q2_GAGyq1_q2_G8Dispatch0I3QoSV0J6SClassOSbtr3_lF">when(fulfilled:_:_:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4when9fulfilled__3qos15cancelOnFailureAA7PromiseVyx_q_q0_tq1_GAGyxq1_G_AGyq_q1_GAGyq0_q1_G8Dispatch0I3QoSV0J6SClassOSbtr2_lF">when(fulfilled:_:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4when9fulfilled_3qos15cancelOnFailureAA7PromiseVyx_q_tq0_GAGyxq0_G_AGyq_q0_G8Dispatch0I3QoSV0J6SClassOSbtr1_lF">when(fulfilled:_:qos:cancelOnFailure:)</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/s:12Tomorrowland4when9fulfilled3qos15cancelOnFailureAA7PromiseVySayxGq_GSayAGyxq_GG_8Dispatch0I3QoSV0J6SClassOSbtr0_lF">when(fulfilled:qos:cancelOnFailure:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/DelayedPromise.html">DelayedPromise</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Promise.html">Promise</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Promise/Resolver.html">– Resolver</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/PromiseCancellable.html">PromiseCancellable</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/TokenPromise.html">TokenPromise</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:12Tomorrowland17StdDelayedPromisea">StdDelayedPromise</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:12Tomorrowland10StdPromisea">StdPromise</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h1 id='tomorrowland' class='heading'>Tomorrowland</h1>

<p><a href="https://github.com/lilyball/Tomorrowland/releases/latest"><img src="https://img.shields.io/badge/version-v1.1.0-blue.svg" alt="Version"></a>
<img src="https://img.shields.io/badge/platforms-ios%20%7C%20macos%20%7C%20watchos%20%7C%20tvos-lightgrey.svg" alt="Platforms">
<img src="https://img.shields.io/badge/languages-swift%20%7C%20objc-orange.svg" alt="Languages">
<img src="https://img.shields.io/badge/license-MIT%2FApache-blue.svg" alt="License">
<img src="https://img.shields.io/cocoapods/v/Tomorrowland.svg" alt="CocoaPods">
<a href="https://github.com/carthage/carthage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible"></a></p>

<p>Tomorrowland is an implementation of <a href="https://en.wikipedia.org/wiki/Futures_and_promises">Promises</a> for Swift and Objective-C. A Promise is a wrapper around an
asynchronous task that provides a standard way of subscribing to task resolution as well as chaining promises together.</p>
<pre class="highlight swift"><code><span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">true</span>
<span class="kt">MyAPI</span><span class="o">.</span><span class="nf">requestFeed</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">user</span><span class="p">)</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="p">(</span><span class="n">feedItems</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">refreshUI</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">feedItems</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">self</span><span class="o">.</span><span class="nf">showError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">always</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
    <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">isNetworkActivityIndicatorVisible</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre>

<p>It is loosely based on both <a href="http://promisekit.org/">PromiseKit</a> and <a href="https://github.com/malcommac/Hydra">Hydra</a>, with a few key distinctions:</p>

<ul>
<li>It uses atomics internally instead of creating a separate <code>DispatchQueue</code> for each promise. This means it&rsquo;s faster and uses fewer resources.</li>
<li>It provides full support for cancellable promises. PromiseKit supports detection of <q>cancelled</q> errors but has no way to request cancellation of a promise. Hydra
supports cancelling a promise, but it can&rsquo;t actually stop any work being done by the promise unless the promise body itself polls for the cancellation status (so e.g.
a promise wrapping a network task can&rsquo;t reasonably cancel the network task). Tomorrowland improves on this by allowing the promise body to observe the
cancelled state, and allows linking cancellation of a child promise to its parent.</li>
<li>Its Obj-C support makes use of generics for improved type safety and better documentation.</li>
<li>Like Hydra but unlike PromiseKit, it provides a way to suppress a registered callback (e.g. because you don&rsquo;t care about the result anymore and don&rsquo;t want stale
data affecting your UI). This is distinct from promise cancellation.</li>
<li>Tomorrowland promises are fully generic over the error type, whereas both PromiseKit and Hydra only support using <code>Error</code> as the error type. This may result in
more typing to construct a promise but it allows for much more powerful error handling. Tomorrowland also has some affordances for working with promises that
use <code>Error</code> as the error type.</li>
<li>Tomorrowland is fully thread-safe. I have no reason to believe PromiseKit isn&rsquo;t, but (at the time of this writing) there are parts of Hydra that are incorrectly
implemented in a non-thread-safe manner.</li>
</ul>
<h2 id='installation' class='heading'>Installation</h2>
<h3 id='manually' class='heading'>Manually</h3>

<p>You can add Tomorrowland to your workspace manually like any other project and add the resulting <code>Tomorrowland.framework</code> to your application&rsquo;s frameworks.</p>
<h3 id='carthage' class='heading'>Carthage</h3>
<pre class="highlight plaintext"><code>github "lilyball/Tomorrowland" ~&gt; 1.0
</code></pre>

<p>The project file is configured to use Swift 5. The code can be compiled against Swift 4.2 instead, but I&rsquo;m not aware of any way to instruct Carthage to override the
swift version during compilation.</p>
<h3 id='cocoapods' class='heading'>CocoaPods</h3>
<pre class="highlight ruby"><code><span class="n">pod</span> <span class="s1">'Tomorrowland'</span><span class="p">,</span> <span class="s1">'~&gt; 1.0'</span>
</code></pre>

<p>The podspec declares support for both Swift 4.2 and Swift 5.0, but selecting the Swift version requires using CoocaPods 1.7.0 or later. When using CocoaPods 1.6
or earlier the Swift version will default to 5.0.</p>
<h3 id='swiftpm' class='heading'>SwiftPM</h3>

<p>Tomorrowland currently relies on a private Obj-C module for its atomics. This arrangement means it is not compatible with Swift Package Manager (as adding
compatibility would necessitate publicly exposing the private Obj-C module).</p>
<h2 id='usage' class='heading'>Usage</h2>
<h3 id='creating-promises' class='heading'>Creating Promises</h3>

<p>Promises can be created using code like the following:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span><span class="kt">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">resolver</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">try</span> <span class="nf">expensiveCalculation</span><span class="p">()</span>
    <span class="n">resolver</span><span class="o">.</span><span class="nf">fulfill</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
<span class="p">})</span>
</code></pre>

<p>The body of this promise runs on the specified <code><a href="Enums/PromiseContext.html">PromiseContext</a></code>, which in this case is <code>.utility</code> (which means <code>DispatchQueue.global(qos: .utility)</code>).
Unlike callbacks, all created promises must specify a context, so as to avoid accidentally running expensive computations on the main thread. The available contexts
include <code>.main</code>, every Dispatch QoS, a specific <code>DispatchQueue</code>, a specific <code>OperationQueue</code>, or the value <code>.immediate</code> which means to run the block
synchronously. There&rsquo;s also the special context <code>.auto</code>, which evaluates to <code>.main</code> on the main thread and <code>.default</code> otherwise.</p>

<p><strong>Note:</strong> The <code>.immediate</code> context can be dangerous to use for callback handlers and should be avoided in most cases. It&rsquo;s primarily intended for creating
promises, and whenever it&rsquo;s used with a callback handler the handler must be prepared to execute on <em>any thread</em>. For callbacks it&rsquo;s usually only useful for short
thread-agnostic callbacks, such as an <code>.onRequestCancel</code> that does nothing more than cancelling a <code>URLSessionTask</code>.</p>

<p>The body of a <code><a href="Structs/Promise.html">Promise</a></code> receives a <q>resolver</q>, which it must use to fulfill, reject, or cancel the promise. If the resolver goes out of scope without being used, the
promise is automatically cancelled. If the promise&rsquo;s error type is <code>Error</code>, the promise body may also throw an error (as seen above), which is then used to reject the
promise. This resolver can also be used to observe cancellation requests using <code>resolver.onRequestCancel</code>, as seen here:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">promise</span> <span class="o">=</span> <span class="kt">Promise</span><span class="o">&lt;</span><span class="kt">Data</span><span class="p">,</span><span class="kt">Error</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">immediate</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">resolver</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="n">urlSession</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span> <span class="nv">completionHandler</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="n">data</span> <span class="p">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="nf">fulfill</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">case</span> <span class="kt">URLError</span><span class="o">.</span><span class="n">cancelled</span><span class="p">?</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">resolver</span><span class="o">.</span><span class="nf">reject</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">error</span><span class="o">!</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="n">resolver</span><span class="o">.</span><span class="nf">onRequestCancel</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">immediate</span><span class="p">,</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
        <span class="n">task</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="n">task</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
<span class="p">})</span>
</code></pre>

<p>Resolvers also have a convenience method <code>handleCallback()</code> that is intended to make it easy to wrap framework callbacks in promises. This method returns a
closure that can be used as a callback directly. It also takes an optional <code>isCancelError</code> parameter that can be used to indicate when an error represents
cancellation. For example:</p>
<pre class="highlight swift"><code><span class="n">geocoder</span><span class="o">.</span><span class="nf">reverseGeocodeLocation</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nv">completionHandler</span><span class="p">:</span> <span class="n">resolver</span><span class="o">.</span><span class="nf">handleCallback</span><span class="p">(</span><span class="nv">isCancelError</span><span class="p">:</span> <span class="p">{</span> <span class="kt">CLError</span><span class="o">.</span><span class="n">geocodeCanceled</span> <span class="o">~=</span> <span class="nv">$0</span> <span class="p">}))</span>
</code></pre>
<h3 id='using-promises' class='heading'>Using Promises</h3>

<p>Once you have a promise, you can register callbacks to be executed when the promise is resolved. Most callback methods require a context, but for some of them
(<code>then</code>, <code>catch</code>, <code>always</code>, and <code>tryThen</code>) you can omit the context and it will default to <code>.auto</code>, which means the main thread if the callback is registered from the
main thread, otherwise the dispatch queue with QoS <code>.default</code>.</p>

<p>When you register a callback, the method also returns a <code><a href="Structs/Promise.html">Promise</a></code>. All callback registration methods return a new <code><a href="Structs/Promise.html">Promise</a></code> even if the callback doesn&rsquo;t affect the
value of the promise. The reason for this is so chained callbacks always guarantee that the previous callback finished executing before the new one starts, even
when using concurrent contexts (e.g. <code>.utility</code>), and so cancelling the returned promise doesn&rsquo;t cancel the original one if any other callbacks were registered on
it.</p>

<p>Most callback registration methods also have versions that allow you to return a <code><a href="Structs/Promise.html">Promise</a></code> from your callback. In this event, the resulting <code><a href="Structs/Promise.html">Promise</a></code> waits for the
promise you returned to resolve before adopting its value. This allows for easy composition of promises.</p>
<pre class="highlight swift"><code><span class="nf">showLoadingIndicator</span><span class="p">()</span>
<span class="nf">fetchUserCredentials</span><span class="p">()</span><span class="o">.</span><span class="nf">flatMap</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="k">default</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">credentials</span><span class="p">)</span> <span class="k">in</span>
    <span class="c1">// This returns a new promise</span>
    <span class="k">return</span> <span class="kt">MyAPI</span><span class="o">.</span><span class="nf">login</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">credentials</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nv">password</span><span class="p">:</span> <span class="n">credentials</span><span class="o">.</span><span class="n">password</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">then</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">apiKey</span><span class="p">)</span> <span class="k">in</span>
    <span class="c1">// this is invoked when the promise returned by MyAPI.login fulfills.</span>
    <span class="kt">MyAPI</span><span class="o">.</span><span class="n">apiKey</span> <span class="o">=</span> <span class="n">apiKey</span>
    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">transitionToLoggedInState</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="n">always</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">_</span> <span class="k">in</span>
    <span class="c1">// This is always invoked regardless of whether the previous chain was</span>
    <span class="c1">// fulfilled, rejected, or cancelled.</span>
    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">hideLoadingIndicator</span><span class="p">()</span>
<span class="p">}</span><span class="o">.</span><span class="k">catch</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
    <span class="c1">// this handles any error returned from the previous chain, meaning any error</span>
    <span class="c1">// from `fetchUserCredentials()` or from `MyAPI.login(name:password:)`.</span>
    <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">displayError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>When composing callbacks that return promises, you may run into issues with incompatible error types. There are convenience methods for working with promises
whose errors are compatible with <code>Error</code>, but they don&rsquo;t cover all cases. If you find yourself hitting one of these cases, any <code><a href="Structs/Promise.html">Promise</a></code> whose error type conforms to
<code>Error</code> has a property <code>.upcast</code> that will convert that error into an <code>Error</code> to allow for easier composition of promises.</p>

<p>Tomorrowland also offers a typealias <code><a href="Typealiases.html#/s:12Tomorrowland10StdPromisea">StdPromise&lt;Value&gt;</a></code> as shorthand for <code><a href="Structs/Promise.html">Promise&lt;T,Error&gt;</a></code>. This is frequently useful to avoid having to repeat the types,
such as with <code>StdPromise(fulfilled: someValue)</code> instead of <code>Promise&lt;SomeValue,Error&gt;(fulfilled: someValue)</code>.</p>
<h3 id='cancelling-and-invalidation' class='heading'>Cancelling and Invalidation</h3>

<p>All promises expose a method <code>.requestCancel()</code>. It is named such because this doesn&rsquo;t actually guarantee that the promise will be cancelled. If the promise
supports cancellation, this method will trigger a callback that the promise can use to cancel its work. But promises that don&rsquo;t support cancellation will ignore this
and will eventually fulfill or reject as normal. Naturally, requesting cancellation of a promise that has already been resolved does nothing, even if the callbacks have
not yet been invoked.</p>

<p>In order to handle the issue of a promise being resolved after you no longer care about it, there is a separate mechanism called a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>
that can be used to suppress callbacks. All callback methods have an optional <code>token</code> parameter that accepts a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>.  If provided,
calling <code>invalidate()</code> on the token prior to the callback being executed guarantees the callback will not fire. If the callback returns a value that is required in order
to resolve the <code><a href="Structs/Promise.html">Promise</a></code> returned from the callback registration method, the resulting <code><a href="Structs/Promise.html">Promise</a></code> is cancelled instead. <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s can be used
with multiple callbacks at once, and a single token can be re-used as much as desired. It is recommended that you take advantage of both invalidation tokens and
cancellation. This may look like</p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">URLImageView</span><span class="p">:</span> <span class="kt">UIImageView</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">promise</span><span class="p">:</span> <span class="kt">StdPromise</span><span class="o">&lt;</span><span class="kt">Void</span><span class="o">&gt;</span><span class="p">?</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">invalidationToken</span> <span class="o">=</span> <span class="kt">PromiseInvalidationToken</span><span class="p">()</span>

    <span class="kd">enum</span> <span class="kt">LoadError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">dataIsNotImage</span>
    <span class="p">}</span>

    <span class="c1">/// Loads an image from the URL and displays it in the image view.</span>
    <span class="kd">func</span> <span class="nf">loadImage</span><span class="p">(</span><span class="n">from</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">promise</span><span class="p">?</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
        <span class="n">invalidationToken</span><span class="o">.</span><span class="nf">invalidate</span><span class="p">()</span>
        <span class="c1">// Note: dataTaskAsPromise does not actually exist</span>
        <span class="n">promise</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskAsPromise</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
        <span class="c1">// Use `_ =` to avoid having to handle errors with `.catch`.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">promise</span><span class="p">?</span><span class="o">.</span><span class="nf">tryMap</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">image</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">LoadError</span><span class="o">.</span><span class="n">dataIsNotImage</span>
            <span class="p">}</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">token</span><span class="p">:</span> <span class="n">invalidationToken</span><span class="p">,</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p><code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code> also has a method <code>.requestCancelOnInvalidate(_:)</code> that can register any number of <code><a href="Structs/Promise.html">Promise</a></code>s to be automatically
requested to cancel (using <code>.requestCancel()</code>) the next time the token is invalidated. <code><a href="Structs/Promise.html">Promise</a></code> also has the same method (except it takes a token as the
argument) as a convenience for calling <code>.requestCancelOnInvalidate(_:)</code> on the token. This can be used to terminate a promise chain without ever assigning
the promise to a local variable. <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code> also has a method <code>.cancelWithoutInvalidating()</code> which cancels any associated promises
without invalidating the token.</p>

<p>By default <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s will invalidate themselves automatically when deinitialized. This is primarily useful in conjunction with
<code>requestCancelOnInvalidate(_:)</code> as it allows you to automatically cancel your promises when object that owns the token deinits. This behavior can be
disabled with an optional parameter to <code>init</code>.</p>

<p><code><a href="Structs/Promise.html">Promise</a></code> also has a convenience method <code>requestCancelOnDeinit(_:)</code> which can be used to request the <code><a href="Structs/Promise.html">Promise</a></code> to be cancelled when a given object
deinits. This is equivalent to adding a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code> property to the object (configured to invalidate on deinit) and requesting cancellation when
the token invalidates, but can be used if the token would otherwise not be explicitly invalidated.</p>

<p>Using these methods, the above <code>loadImage(from:)</code> can be rewritten as the following including cancellation:</p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">URLImageView</span><span class="p">:</span> <span class="kt">UIImageView</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">promiseToken</span> <span class="o">=</span> <span class="kt">PromiseInvalidationToken</span><span class="p">()</span>

    <span class="kd">enum</span> <span class="kt">LoadError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">dataIsNotImage</span>
    <span class="p">}</span>

    <span class="c1">/// Loads an image from the URL and displays it in the image view.</span>
    <span class="kd">func</span> <span class="nf">loadImage</span><span class="p">(</span><span class="n">from</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">promiseToken</span><span class="o">.</span><span class="nf">invalidate</span><span class="p">()</span>
        <span class="c1">// Note: dataTaskAsPromise does not actually exist</span>
        <span class="n">promise</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskAsPromise</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
        <span class="c1">// Use `_ =` to avoid having to handle errors with `.catch`.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">promise</span><span class="p">?</span><span class="o">.</span><span class="nf">tryMap</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">utility</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UIImage</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">image</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">LoadError</span><span class="o">.</span><span class="n">dataIsNotImage</span>
            <span class="p">}</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">token</span><span class="p">:</span> <span class="n">promiseToken</span><span class="p">,</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">requestCancelOnInvalidate</span><span class="p">(</span><span class="n">invalidationToken</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h4 id='invalidation-token-chaining' class='heading'>Invalidation token chaining</h4>

<p><code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s can be arranged in a tree such that invalidating one token will cascade this invalidation down to other tokens. This is
accomplished by calling <code>childToken.chainInvalidation(from: parentToken)</code>. Practically speaking this is no different than just manually invalidating each
child token yourself after invalidating the parent token, but it&rsquo;s provided as a convenience to make it easy to have fine-grained invalidation control while also having
a simple way to bulk-invalidate tokens. For example, you might have separate tokens for different view controllers that all chain invalidation from a single token that
gets invalidated when the user logs out, thus automatically invalidating all your user-dependent network requests at once while still allowing each view controller the
ability to invalidate just its own requests independently.</p>
<h4 id='code-tokenpromise-code' class='heading'><code><a href="Structs/TokenPromise.html">TokenPromise</a></code></h4>

<p>In order to avoid the repetition of passing a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code> to multiple <code><a href="Structs/Promise.html">Promise</a></code> methods as well as cancelling the resulting promise, a type
<code><a href="Structs/TokenPromise.html">TokenPromise</a></code> exists that handles this for you. You can create a <code><a href="Structs/TokenPromise.html">TokenPromise</a></code> with the <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV9withTokenyAA0dB0Vyxq_GAA0b12InvalidationD0VF">Promise.withToken(_:)</a></code> method. This allows you to take code like
the following:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">loadModel</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">promiseToken</span><span class="o">.</span><span class="nf">invalidate</span><span class="p">()</span>
    <span class="kt">MyModel</span><span class="o">.</span><span class="nf">fetchFromNetworkAsPromise</span><span class="p">()</span>
        <span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">token</span><span class="p">:</span> <span class="n">promiseToken</span><span class="p">,</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">updateUI</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">catch</span><span class="p">(</span><span class="nv">token</span><span class="p">:</span> <span class="n">promiseToken</span><span class="p">,</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">handleError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">requestCancelOnInvalidate</span><span class="p">(</span><span class="n">promiseToken</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>And rewrite it to be less repetitive:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">loadModel</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">promiseToken</span><span class="o">.</span><span class="nf">invalidate</span><span class="p">()</span>
    <span class="kt">MyModel</span><span class="o">.</span><span class="nf">fetchFromNetworkAsPromise</span><span class="p">()</span>
        <span class="o">.</span><span class="nf">withToken</span><span class="p">(</span><span class="n">promiseToken</span><span class="p">)</span>
        <span class="o">.</span><span class="nf">then</span><span class="p">({</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">updateUI</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">catch</span><span class="p">({</span> <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="p">?</span><span class="o">.</span><span class="nf">handleError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<h4 id='automatic-cancellation-propagation' class='heading'>Automatic cancellation propagation</h4>

<p>Nearly all callback registration methods will automatically propagate cancellation requests from the child to the parent if the parent has no other observers. If all
observers for a promise request cancellation, the cancellation request will propagate upwards at this time. This means that a promise will not automatically cancel
as long as there&rsquo;s at least one interested observer. Do note that promises that have no observers do not get automatically cancelled, this only happens if there&rsquo;s at
least one observer (which then requests cancellation). Automatic cancellation propagation also requires that the promise itself no longer be in scope. For this reason
you should avoid holding onto promises long-term and instead use the <code>.cancellable</code> property or <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>&lsquo;s
<code>requestCancelOnInvalidate(_:)</code> if you want to be able to cancel the promise later.</p>

<p>Automatic cancellation propagation also works with the utility functions <code>when(fulfilled:)</code> and <code>when(first:)</code> as well as the convenience methods
<code>timeout(on:delay:)</code> and <code>delay(on:_:)</code>.</p>

<p>Promises have a couple of methods that do not participate in automatic cancellation propagation. You can use <code>tap(on:token:_:)</code> as an alternative to <code>always</code> in
order to register an observer that won&rsquo;t interfere with the existing automatic cancellation propagation (this is suitable for inserting into the middle of a promise
chain). You can also use <code>tap()</code> as a more generic version of this.</p>

<p>Note that <code>ignoringCancel()</code> disables automatic cancellation propagation on the receiver. Once you invoke this on a promise, it will never automatically cancel.</p>
<h5 id='code-propagatingcancellation-on-cancelrequested-code' class='heading'><code>propagatingCancellation(on:cancelRequested:)</code></h5>

<p>In some cases you may need to hold onto a promise without blocking cancellation propagation from its children. The primary use-case here is deduplicating access to
an asynchronous resource (such as a network load). In this scenario you may wish to hold onto a promise and return a new child for every client requesting the same
resource, without preventing cancellation of the resource load if all clients cancel their requests. This can be accomplished by holding onto the result of calling
<code>.propagatingCancellation(on:cancelRequested:)</code>. The promise returned from this method will propagate cancellation to its parent as soon as all children
have requested cancellation even if the promise is still in scope. When cancellation is requested, the <code>cancelRequested</code> handler will be invoked immediately prior to
propagating cancellation upwards; this enables you to release your reference to the promise (so a new request by a client will create a brand new resource load). An
example of this might look like:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">loadResource</span><span class="p">(</span><span class="n">at</span> <span class="nv">url</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">promise</span><span class="p">:</span> <span class="kt">StdPromise</span><span class="o">&lt;</span><span class="kt">Model</span><span class="o">&gt;</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">existingPromise</span> <span class="o">=</span> <span class="n">resourceLoads</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">promise</span> <span class="o">=</span> <span class="n">existingPromise</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">promise</span> <span class="o">=</span> <span class="nf">makeResourceRequest</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="nf">propagatingCancellation</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">main</span><span class="p">,</span> <span class="nv">cancelRequested</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">promise</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">if</span> <span class="k">self</span><span class="o">.</span><span class="n">resourceLoads</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">==</span> <span class="n">promise</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">resourceLoads</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="kc">nil</span>
            <span class="p">}</span>
        <span class="p">})</span>
        <span class="n">resourceLoads</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">promise</span>
    <span class="p">}</span>
    <span class="c1">// Return a new child for each request so all clients have to cancel, not just one.</span>
    <span class="k">return</span> <span class="n">promise</span><span class="o">.</span><span class="nf">then</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">immediate</span><span class="p">,</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre>
<h3 id='promise-helpers' class='heading'>Promise Helpers</h3>

<p>There are a few helper functions that can be used to deal with multiple promises.</p>
<h4 id='code-when-fulfilled-code' class='heading'><code>when(fulfilled:)</code></h4>

<p><code>when(fulfilled:)</code> is a global function that takes either an array of promises or 2–6 promises as separate arguments, and returns a single promise that is
eventually fulfilled with the values of all input promises. With the array version all input promises must have the same type and the result is fulfilled with an array.
With the separate argument version the promises may have unique value types (but the same error type) and the result is fulfilled with a tuple.</p>

<p>If any of the input promises is rejected or cancelled, the resulting promise is immediately rejected or cancelled as well. If multiple input promises are rejected or
cancelled, the first such one affects the result.</p>

<p>This function has an optional parameter <code>cancelOnFailure:</code> that, if provided as <code>true</code>, will cancel all input promises if any of them are rejected.</p>
<h4 id='code-when-first-code' class='heading'><code>when(first:)</code></h4>

<p><code>when(first:)</code> is a global function that takes an array of promises of the same type, and returns a single promise that eventually adopts the same value or error as
the first input promise that gets fulfilled or rejected. Cancelled input promises are ignored, unless all input promsies are cancelled, at which point the resulting
promise will be cancelled as well.</p>

<p>This function has an optional parameter <code>cancelRemaining:</code> that, if provided as <code>true</code>, will cancel the remaining input promises as soon as one of them is fulfilled
or rejected.</p>
<h4 id='code-promise-timeout-on-delay-code' class='heading'><code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV7timeout2on5delayACyxAA0B12TimeoutErrorOyq_GGAA0B7ContextO_SdtF">Promise.timeout(on:delay:)</a></code></h4>

<p><code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV7timeout2on5delayACyxAA0B12TimeoutErrorOyq_GGAA0B7ContextO_SdtF">Promise.timeout(on:delay:)</a></code> is a method that returns a new promise that adopts the same value as the receiver, or is rejected with an error if the receiver isn&rsquo;t
resolved within the given interval.</p>
<h4 id='code-promise-delay-on-_-code' class='heading'><code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV5delay2on_ACyxq_GAA0B7ContextO_SdtF">Promise.delay(on:_:)</a></code></h4>

<p><code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV5delay2on_ACyxq_GAA0B7ContextO_SdtF">Promise.delay(on:_:)</a></code> is a method that returns a new promise that adopts the same result as the receiver after the specified delay. It is intended primarily for
testing purposes.</p>
<h3 id='objective-c' class='heading'>Objective-C</h3>

<p>Tomorrowland has Obj-C compatibility in the form of <code>TWLPromise&lt;ValueType,ErrorType&gt;</code>. This is a parallel promise implementation that can be bridged to/from
<code><a href="Structs/Promise.html">Promise</a></code> and supports all of the same functionality. Note that some of the method names are different (due to lack of overloading), and while <code>TWLPromise</code> is
generic over its types, the return values of callback registration methods that return new promises are not parameterized (due to inability to have generic methods).</p>
<h3 id='callback-lifetimes' class='heading'>Callback lifetimes</h3>

<p>Callbacks registered on promises will be retained until the promise is resolved. If a callback is invoked (or would be invoked if the relevant invalidation token hadn&rsquo;t
been invalidated), Tomorrowland guarantees that it will release the callback on the context it was invoked on. If the callback is not invoked (e.g. it&rsquo;s a <code>then(on:_:)</code>
callback but the promise was rejected) then no guarantees are made as to the context the callback is released on. If you need to ensure it&rsquo;s released on the
appropriate context (e.g. if it captures an object that must deallocate on the main thread) then you can use <code>.always</code> or one of the <code>.mapResult</code> variants.</p>
<h2 id='requirements' class='heading'>Requirements</h2>

<p>Requires a minimum of iOS 9, macOS 10.10, watchOS 2.0, or tvOS 9.0.</p>
<h2 id='license' class='heading'>License</h2>

<p>Licensed under either of</p>

<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or
<a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or
<a href="http://opensource.org/licenses/MIT">http://opensource.org/licenses/MIT</a>) at your option.</li>
</ul>
<h3 id='contribution' class='heading'>Contribution</h3>

<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be dual licensed as above, without any additional terms or conditions.</p>
<h2 id='version-history' class='heading'>Version History</h2>
<h3 id='v1-1-0' class='heading'>v1.1.0</h3>

<ul>
<li>Add new method <code>.propagatingCancellation(on:cancelRequested:)</code> that can be used to create a long-lived promise that propagates cancellation from its
children to its parent while it&rsquo;s still alive. Normally promises don&rsquo;t propagate cancellation until they themselves are released, in case more children are going to be
added. This new method is intended to be used when deduplicating requests for an asynchronous resource (such as a network load) such that the resource request
can be cancelled in the event that no children care about it anymore (<a href="https://github.com/lilyball/Tomorrowland/issues/46" title="A way to hold onto a promise without blocking cancellation propagation from children">#46</a>).</li>
</ul>
<h3 id='v1-0-1' class='heading'>v1.0.1</h3>

<ul>
<li>Suppress a warning from the Swift 5.1 compiler about code that the Swift 5.0 compiler requires.</li>
</ul>
<h3 id='v1-0-0' class='heading'>v1.0.0</h3>

<ul>
<li>Fix a rather serious bug where <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s would not deinit as long as any promise whose callback was tied to the token was still unresolved.
This meant that the default <code>invalidateOnDeinit</code> behavior would not trigger and the callback would still fire even though there were no more external references
to the token, and this meant any promises configured to be cancelled when the promise invalidated would not cancel. Tokens used purely for
<code>requestCancelOnInvalidate(_:)</code> would still deallocate, and tokens would still deallocate after any associated promises had resolved.</li>
<li>Tweak the atomic memory ordering used in <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s. After a careful re-reading I don&rsquo;t believe I was issuing the correct fences previously,
making it possible for tokens whose associated promise callbacks were executing concurrently with a call to <code>requestCancelOnInvalidate(_:)</code> to read the
wrong generation value, and for tokens that had <code>requestCancelOnInvalidate(_:)</code> invoked concurrently on multiple threads to corrupt the generation.</li>
<li>Add <code>PromiseInvalidationToken.chainInvalidation(from:)</code> to invalidate a token whenever another token invalidates. This allows for building a tree of
tokens in order to have both fine-grained and bulk invalidation at the same time. Tokens chained together this way stay chained forever (<a href="https://github.com/lilyball/Tomorrowland/issues/43" title="Add PromiseInvalidationToken.chainInvalidation(from: PromiseInvalidationToken)">#43</a>).</li>
<li>Update project file to Swift 5.0. The source already supported this. This change should only affect people using <a href="https://github.com/carthage/carthage">Carthage</a> or anyone adding building this
framework from source.</li>
<li>Update the podspec to list both Swift 4.2 and Swift 5.0. With CocoaPods 1.7.0 or later your <code>Podfile</code> can now declare which version of Swift it&rsquo;s compatible with.
For anyone using CocoaPods 1.6 or earlier it will default to Swift 5.0.</li>
</ul>
<h3 id='v0-6-0' class='heading'>v0.6.0</h3>

<ul>
<li>Make <code><a href="Structs/DelayedPromise.html">DelayedPromise</a></code> conform to <code>Equatable</code> (<a href="https://github.com/lilyball/Tomorrowland/issues/37" title="DelayedPromise should conform to Equatable">#37</a>).</li>
<li>Add convenience functions for working with <code>Swift.Result</code> (<a href="https://github.com/lilyball/Tomorrowland/issues/39" title="Add some minimal support for Result">#39</a>).</li>
<li>Mark all the deprecated functions as unavailable instead. This restores the ability to write code like <code>promise.then({ foo?($0) })</code> without it incorrectly
resolving to the deprecated form of <code>map(_:)</code> (<a href="https://github.com/lilyball/Tomorrowland/issues/35" title="Move deprecations to unavailable">#35</a>).</li>
<li>Rename <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV6resultACyxq_GAA0B6ResultOyxq_G_tcfc">Promise.init(result:)</a></code> and <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV2on6result5afterACyxq_GAA0B7ContextO_AA0B6ResultOyxq_GSdtcfc">Promise.init(on:result:after:)</a></code> to <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV4withACyxq_GAA0B6ResultOyxq_G_tcfc">Promise.init(with:)</a></code> and <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV2on4with5afterACyxq_GAA0B7ContextO_AA0B6ResultOyxq_GSdtcfc">Promise.init(on:with:after:)</a></code> (<a href="https://github.com/lilyball/Tomorrowland/issues/40" title="Rename Promise.init(result:) to Promise.init(with:)">#40</a>).</li>
</ul>
<h3 id='v0-5-1' class='heading'>v0.5.1</h3>

<ul>
<li>When chaining multiple <code>.main</code> context blocks in the same runloop pass, ensure we release each block before executing the next one.</li>
<li>Ensure that if a user-supplied callback is invoked, it is also released on the context where it was invoked (<a href="https://github.com/lilyball/Tomorrowland/issues/38" title="Dealloc completion blocks on the context they&#39;re scheduled on">#38</a>).</li>
</ul>

<p>This guarantee is only made for callbacks that are invoked (ignoring tokens). What this means is when using e.g. <code>.then(on:_:)</code> if the promise is fulfilled, the
  <code>onSuccess</code> block will be released on the provided context, but if the promise is rejected no such guarantee is made. If you rely on the context it&rsquo;s released on
  (e.g. it captures an object that must deallocate on the main thread) then you can use <code>.always</code> or one of the <code>mapResult</code> variants.</p>
<h3 id='v0-5-0' class='heading'>v0.5.0</h3>

<ul>
<li>Rename a lot of methods on <code><a href="Structs/Promise.html">Promise</a></code> and <code><a href="Structs/TokenPromise.html">TokenPromise</a></code> (<a href="https://github.com/lilyball/Tomorrowland/issues/5" title="Should we adopt .map, .flatMap terminology?">#5</a>).</li>
</ul>

<p>This gets rid of most overrides, leaving the only overridden methods to be ones that handle either <code>Swift.Error</code> or <code>E: Swift.Error</code>, and even these overrides
  are removed in the Swift 5 compiler.</p>

<p><code>then</code>  is now <code>map</code> or <code>flatMap</code>, <code>recover</code>&rsquo;s override is now <code>flatMapError</code>, <code>always</code>&rsquo;s override is now <code>flatMapResult</code>, and similar renames were made for
  the <code>try</code> variants.</p>

<ul>
<li>Add a new <code>then</code> method whose block returns <code>Void</code>. The returned promise resolves to the same result as the original promise.</li>
<li>Add new <code>mapError</code> and <code>tryMapError</code> methods.</li>
<li>Add new <code>mapResult</code> and <code>tryMapResult</code> methods.</li>
<li>Extend <code>tryFlatMapError</code> to be available on all <code><a href="Structs/Promise.html">Promise</a></code>s instead of just those whose error type is <code>Swift.Error</code>.</li>
<li>Remove the default <code>.auto</code> value for the <code>on context:</code> parameter to most calls. It&rsquo;s now only provided for the <q>terminal</q> callbacks, the ones that don&rsquo;t return a
value from the handler. This avoids the common problem of running trivial maps on the main thread unnecessarily (<a href="https://github.com/lilyball/Tomorrowland/issues/33" title="Remove default context parameter from map, etc">#33</a>).</li>
</ul>
<h3 id='v0-4-3' class='heading'>v0.4.3</h3>

<ul>
<li>Fix compatibility with Xcode 10.2 / Swift 5 compiler (<a href="https://github.com/lilyball/Tomorrowland/issues/31" title="\&quot;Ambiguous use of Promise.pipe(to:)\&quot; error building with Xcode 10.2 Beta 1 in Swift 4 mode">#31</a>, <a href="https://bugs.swift.org/browse/SR-9753" title="REGRESSION: Ambiguity involving overloads and generics constrained by Error">SR-9753</a>).</li>
</ul>
<h3 id='v0-4-2' class='heading'>v0.4.2</h3>

<ul>
<li>Add new method <code>Promise.Resolver.resolve(with: somePromise)</code> that resolves the receiver using another promise (<a href="https://github.com/lilyball/Tomorrowland/issues/30" title="Add Promise.Resolver.resolve(with: somePromise)">#30</a>).</li>
</ul>
<h3 id='v0-4-1' class='heading'>v0.4.1</h3>

<ul>
<li>Mark <code><a href="Structs/PromiseCancellable.html#/s:12Tomorrowland18PromiseCancellableV13requestCancelyyF">PromiseCancellable.requestCancel()</a></code> as <code>public</code> (<a href="https://github.com/lilyball/Tomorrowland/issues/29" title="PromiseCancellable.requestCancel() isn&#39;t public">#29</a>).</li>
</ul>
<h3 id='v0-4' class='heading'>v0.4</h3>

<ul>
<li>Improve the behavior of <code>.delay(on:_:)</code> and <code>.timeout(on:delay:)</code> when using <code>PromiseContext.operationQueue</code>. The relevant operation is now added
to the queue immediately and only becomes ready once the delay/timeout has elapsed.</li>
<li>Add <code>-[TWLPromise initCancelled]</code> to construct a pre-cancelled promise.</li>
<li>Add <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV2on9fulfilled5afterACyxq_GAA0B7ContextO_xSdtcfc">Promise.init(on:fulfilled:after:)</a></code>, <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV2on8rejected5afterACyxq_GAA0B7ContextO_q_Sdtcfc">Promise.init(on:rejected:after:)</a></code>, and <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV2on6result5afterACyxq_GAA0B7ContextO_AA0B6ResultOyxq_GSdtcfc">Promise.init(on:result:after:)</a></code>. These initializers produce
something akin to <code>Promise(fulfilled: value).delay(after)</code> except they respond to cancellation immediately. This makes them more suitable for use as
cancellable timers, as opposed to <code>.delay(_:)</code> which is more intended for debugging (<a href="https://github.com/lilyball/Tomorrowland/issues/27" title="Add Promise(fulfilled:after:) and Promise(rejected:after:)">#27</a>).</li>
<li>Try to clean up the callback list when calling <code><a href="Structs/PromiseInvalidationToken.html#/s:12Tomorrowland24PromiseInvalidationTokenV25requestCancelOnInvalidateyyAA0B0Vyxq_Gr0_lF">PromiseInvalidationToken.requestCancelOnInvalidate(_:)</a></code>. Any deallocated promises at the head of the
callback list will be removed. This will help keep the callback list from growing uncontrollably when a token is used merely to cancel all promises when the owner
deallocates as opposed to being periodically invalidated during its lifetime (<a href="https://github.com/lilyball/Tomorrowland/issues/25" title="PromiseInvalidationTokenBox should clean up the callback list when possible">#25</a>).</li>
<li>Cancel the <code>.delay(_:)</code> timer if <code>.requestCancel()</code> is invoked and the upstream promise cancelled. This way requested cancels will skip the delay, but
unexpected cancels will still delay the result (<a href="https://github.com/lilyball/Tomorrowland/issues/26" title="Make delay cancelable">#26</a>).</li>
</ul>
<h3 id='v0-3-4' class='heading'>v0.3.4</h3>

<ul>
<li>Add <code><a href="Structs/PromiseInvalidationToken.html#/s:12Tomorrowland24PromiseInvalidationTokenV25cancelWithoutInvalidatingyyF">PromiseInvalidationToken.cancelWithoutInvalidating()</a></code>. This method cancels any associated promises without invalidating the token, thus
allowing for any <code>onCancel</code> and <code>always</code> handlers on the promises to fire (<a href="https://github.com/lilyball/Tomorrowland/issues/23" title="Add PromiseInvalidationToken.cancelWithoutInvalidation()">#23</a>).</li>
<li>Add missing <code>Promise</code>↔<code>ObjCPromise</code> bridging methods for the case of <code>Value: AnyObject, Error == Swift.Error</code> (<a href="https://github.com/lilyball/Tomorrowland/issues/24" title="Add Swift&lt;-&gt;ObjC bridging methods for Value: AnyObject, Error == Swift.Error">#24</a>).</li>
</ul>
<h3 id='v0-3-3' class='heading'>v0.3.3</h3>

<ul>
<li>Add initializer <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV6resultACyxq_GAA0B6ResultOyxq_G_tcfc">Promise.init(result:)</a></code> for creating a <code><a href="Structs/Promise.html">Promise</a></code> from a <code><a href="Enums/PromiseResult.html">PromiseResult</a></code>.</li>
<li>Fix cancellation propagation issue with <code>when(resolved: …, cancelOnFailure: true)</code> and <code>when(first: …, cancelRemaining: true)</code> (<a href="https://github.com/lilyball/Tomorrowland/issues/20" title="when does not work as expected when using `cancelOnFailure: true`">#20</a>).</li>
<li>Update some documentation.</li>
<li>Enable <code>APPLICATION_EXTENSION_API_ONLY</code>.</li>
</ul>
<h3 id='v0-3-2' class='heading'>v0.3.2</h3>

<ul>
<li>Add <code>Hashable</code> / <code>Equatable</code> conformance to <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>.</li>
<li>Add a new type <code><a href="Structs/TokenPromise.html">TokenPromise</a></code> that wraps a <code><a href="Structs/Promise.html">Promise</a></code> and automatically applies a <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>. This API is Swift-only.</li>
</ul>
<h3 id='v0-3-1' class='heading'>v0.3.1</h3>

<ul>
<li>Add a missing Swift-&gt;ObjC convenience bridging method.</li>
<li>Add <code>Decodable</code> conformance to <code><a href="Enums/NoError.html">NoError</a></code>.</li>
<li>Add method <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV4forkyACyxq_GyAEKXEKF">Promise.fork(_:)</a></code>.</li>
<li>Fix compilation failure when targeting 32-bit iOS 9 simulator in Xcode 9.3.</li>
<li>Fix cancellation propagation test cases on iOS 9 simulators.</li>
</ul>
<h3 id='v0-3' class='heading'>v0.3</h3>

<ul>
<li>Add <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV25requestCancelOnInvalidateyACyxq_GAA0B17InvalidationTokenVF">Promise.requestCancelOnInvalidate(_:)</a></code> as a convenience for <code>token.requestCancelOnInvalidate(_:)</code>.</li>
<li>Add <code><a href="Structs/Promise.html#/s:12Tomorrowland7PromiseV21requestCancelOnDeinityACyxq_GyXlF">Promise.requestCancelOnDeinit(_:)</a></code> as a convenience for adding a token property to an object that invalites on deinit.</li>
<li>Better support for <code>OperationQueue</code> with <code>delay</code>/<code>timeout</code>. Instead of using the <code>OperationQueue</code>&rsquo;s underlying queue, we instead use a <code>.userInitiated</code>
queue for the timer and hop onto the <code>OperationQueue</code> to resolve the promise.</li>
</ul>
<h3 id='v0-2' class='heading'>v0.2</h3>

<ul>
<li>Implement automatic cancellation propagation and remove the <code>.linkCancel</code> option.</li>
<li>Remove the <code>cancelOnTimeout:</code> parameter to <code>timeout(on:delay:)</code> in favor of automatic cancellation propagation.</li>
<li>Automatically invalidate <code><a href="Structs/PromiseInvalidationToken.html">PromiseInvalidationToken</a></code>s on <code>deinit</code>. This behavior can be disabled via a parameter to <code>init</code>.</li>
</ul>
<h3 id='v0-1' class='heading'>v0.1</h3>

<p>Initial alpha release.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2019 <a class="link" href="https://github.com/lilyball/Tomorrowland" target="_blank" rel="external">Lily Ballard</a>. All rights reserved. (Last updated: 2019-11-25)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.12.0</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
